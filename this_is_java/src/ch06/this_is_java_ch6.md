# 6. 클래스
## 1. 객체 지향 프로그래밍
- 객체 지향 프로그래밍(OOP): 부품에 해당하는 객체들을 먼저 만들고, 이 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법
### 객체란?
- 객체: 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것.
  - 속성: 필드
  - 동작: 메소드
- 객체 모델링: 현실 세계 객체의 대표 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정(설계)
### 객체의 상호작용
- 현실 세계에서 일어나는 모든 현상은 객체와 객체 간의 상호작용으로 이루어져있음. 
- 객체 지향 프로그램에서도 객체들은 다른 객체와 서로 상호작용(수단=메소드)하며 동작: 객체가 다른 객체의 기능을 이용할때 이 메소드를 호출
- 메소드 호출을 통해 객체들은 데이터를 서로 주고 받음. 
  - `메소드(매개값1, 매개값2, ...);`: 전달하고자 하는 데이터 = 매개값
  - `타입 변수 = 메소드(매개값1, 매개값2)`: 메소드의 실행의 결과=리턴값
### 객체 간의 관계
- 집합 관계: 완성품과 부품의 관계
- 사용 관계: 다른 객체의 필드를 읽고 변경하거나 메소드를 호출하는 관계
- 상속 관계: 부모와 자식 관계(물려받음)
### 객체 지향 프로그래밍의 특징
#### 캡슐화
- 객체의 데이터(필드), 동작(메소드)을 하나로 묶고 실제 구현 내용을 외부에 감추는 것. 
- 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용
- 접근 제한자: 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정
#### 상속
- 부모 객체가 자기가 가지고 있는 필드와 메소드를 자식 객체에게 물려주어 자식 객체가 사용할 수 있게 함
  - 코드의 재사용성을 높여줌
  - 유지 보수 시간을 최소화
#### 다형성
- 사용방법은 동일하지만 실행 결과가 다양하게 나오는 성질
- 자동 타입 변환, 재정의 기술이 필요(상속+인터페이스 구현을 통해 얻어짐)
## 2. 객체와 클래스
- 객체를 생성하기 위해서 설계도에 해당하는 클래스가 필요
- 클래스로부터 생성된 객체를 해당 클래스의 인스턴스라고 부름
- 인스턴스화: 클래스로부터 객체를 만드는 과정
## 3. 클래스 선언
- 클래스 선언=객체 생성을 위한 설계도를 작성하는 작업, 필드(가져야할 데이터)와 메서드(객체의 동작)이 무엇인지 정의하는 내용 `public class 클래스명 { }`
- 하나의 소스 파일은 복수 개의 클래스 선언을 포함 가능 -> 복수 개의 클래스 선언이 포함된 소스 파일을 컴파일하면 클래스 선언 수만큼의 바이트코드 파일이 생김.
  - 하나의 소스 파일에 복수 개의 클래스를 선언 시 소스 파일명과 동일한 클래스만 공개 클래스(public)로 선언 가능.
## 4. 객체 생성과 클래스 변수
- 클래스로부터 객체를 생성 시 객체 생성 연산자 **new**가 필요.
  - `클래스 변수 = new 클래스()`: 생성자 호출 코드(클래스()) + new연산자: 객체 생성 후 객체 주소 리턴 -> 클래스 변수에 대입 가능
  - 스택 영역에 생긴 클래스 변수가 생성된 객체의 주소를 가지고 힙 영역에 생성된 객체를 참조하는 형태
- 클래스의 두 가지 용도
  - 라이브러리(library) 클래스: 실행 불가, 다른 클래스에서 이용하는 클래스
  - 실행 클래스: main() 메소드를 가지고 있는 실행 가능한 클래스
## 5. 클래스의 구성 멤버
- 클래스 선언: 객체 초기화 역할을 담당하는 생성자 + 객체에 포함될 필드, 메소드 선언
- 클래스 구성 멤버
  - 필드: 객체의 데이터를 저장하는 역할(~=변수 선언과 형태는 비슷; 쓰임새는 다름)
  - 생성자: new 연산자로 객체를 생성할 때 객체의 초기화 역할 담당, 선언 형태는 메소드와 비슷하지만 리턴 타입이 없고 클래스 이름과 동일한 이름.
  - 메소드: 객체가 수행할 동작(=함수라고 부르기도 하지만 객체 내부의 함수는 메소드라고 부름), 객체와 객체 간의 상호 작용을 위해 호출됨
## 6. 필드 선언과 사용
- 객체의 데이터(고유 데이터, 현재 상태 데이터, 부품 데이터)를 저장
### 필드 선언
- 변수를 선언하는 방법과 동일하지만 클래스 블록에서 선언해야함.
- `타입 필드명 [ = 초기값]`
> 필드와 (로컬)변수의 차이점
> - (로컬)변수: 생성자와 메소드 블록에서 선언, 생성자와 메소드 호출시에만 생성 및 사용됨
> - 필드: 클래스 블록에서 선언, 객체 내부에 존재, 객체 내외부에서 사용 가능.
- 타입: 필드에 저장할 데이터의 종류(기본타입 + 참조타입)
- 필드명: 첫 문자를 소문자로 하되 캐멀 스타일로 작성하는 것이 관례
- 초기값을 제공하지 않을 경우 객체 생성 시 자동으로 기본값으로 초기화됨.(0, flase, null)
### 필드 사용
- 필드를 사용한다는 것 = 필드값을 읽고 변경하는 것
- 클래스에서 선언 후 객체를 생성해야 사용 가능
- 객체 내부의 생성자와 메소드 내부에서 사용 가능(필드명 사용), 객체 외부에서도 접근해서 사용 가능(참조 변수와 도트 연산자-객체 접근 연산자-를 이용)
## 7. 생성자 선언과 호출
- new 연산자: 객체를 생성한 후 연이어 생성자를 호출해서 객체를 초기화하는 역할, 생성자의 실행이 끝나면 객체의 주소를 리턴
  - 객체 초기화: 필드 초기화, 메소드를 호출해서 객체를 사용할 준비를 하는 것.
### 기본 생성자
- 모든 클래스는 생성자가 존재, 하나 이상을 가질 수 있음
- 클래스에 생성자 선언이 없으면 컴파일러는 기본 생성자를 바이트코드 파일에 자동으로 추가시킴
  - 기본 생성자: `[public] 클래스() { }`
  - 클래스가 public class인 경우 기본 생성자에도 public이 붙음
  - 클래스가 class로만 선언된 경우 기본 생성자에도 public이 붙지 않음.
- 개발자가 명시적으로 선언한 생성자가 있다면 컴파일러는 기본 생성자를 추가하지 않음
### 생성자 선언
- 객체를 다양하게 초기화하기 위해 생성자를 직접 선언
- `클래스(매개변수, ...) { //객체의 초기화 코드 }`
- 생성자는 메소드와 비슷한 모양을 가지고 있으나, **리턴 타입이 없고** 클래스 이름과 동일.
- 매개변수: new 연산자로 생성자를 호출할 때 매개값 생성자 블록 내부로 전달하는 역할.
- 매개변수의 타입은 매개값의 종류에 맞게 작성
### 필드 초기화
- 객체마다 동일한 값을 갖고 있다면 필드 선언 시 초기값을 대입하는 것이 좋고, 객체마다 다른 값을 가져야한다면 생성자에서 필드를 초기화.
- 생성자의 매개값은 new 연산자로 생성자를 호출할 때 주어짐.
### 생성자 오버로딩
- 매개값으로 객체의 필드를 다양하게 초기화하려면 생성자 오버로딩(매개변수를 달리하는-타입, 개수, 순서- 생성자를 여러 개 선언하는 것)이 필요.(매개변수 이름만 바꾸는 것은 생성자 오버로딩이 아님)
- 생성자가 오버로딩되어 있을 경우, new 연산자로 생성자를 호출할때 제공되는 매개값의 타입과 수에 따라 실행될 생성자가 결정                           
### 다른 생성자 호출
- 생성자 오버로딩이 많아져서 중복 코드가 많이 발생하는 경우(매개변수의 수만 다르고 필드 초기화 내용이 비슷한 경우) -> 공통 코드를 한 생성자에만 집중적으로 작성, 나머지 생성자는 this(매개값, ...)를 생성자의 첫 줄에 작성하여 다른 생성자를 호출 -> 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 실행.
## 8. 메소드 선언과 호출
- 메소드 선언: 객체의 동작을 실행 블록으로 정의하는 것
- 메소드 호출: 실행 블록을 실제로 실행하는 것
- 메소드는 객체 내외부에서 호출될 수 있기 때문에 객체 간의 상호작용하는 방법을 정의하는 것.
### 메소드 선언
- `리턴타입 메소드명 (매개변수, ...) { //실행코드작성 }`
#### 리턴 타입
- 메소드가 실행한 후 호출한 곳으로 전달하는 결과값의 타입
- 리턴값이 없는 메소드는 void로 작성
- 리턴 타입이 있는 메소드는 실행 블록 안에서 return문으로 리턴값을 지정해야함.
#### 메소드명
- 첫 문자를 소문자로 시작
- 캐멀 스타일
#### 매개변수
- 메소드를 호출할 때 전달한 매개값을 받기 위해 사용
- 전달할 매개값이 없다면 생략 가능
#### 실행 블록
- 메소드 호출 시 실행되는 부분
### 메소드 호출
- 메소드 호출 = 메소드 블록 실행
- 메소드 선언 후 객체가 생성되었을때 메소드 호출 가능(메소드는 객체의 동작이므로)
  - 객체 내부: 메소드명
  - 객체 외부: 참조 변수와 도트연산자(.), 매개변수의 타입과 수에 맞게 매개값 제공, 리턴값이 있을 경우에 대입 연산자를 통해 변수에 저장 가능
#### 가변길이 매개변수
- 메소드 호출 시 매개변수의 개수에 맞게 매개값을 제공해야함. -> **가변길이 매개변수**를 가지고 있다면 매개변수의 개수와 상관없이 매개값을 줄 수 있음
- 가변길이 매개변수의 선언: `int sum(int ... values)`
- 가변길이 매개변수 전달: `int result = sum(1, 2, 3);`, `int result = sum(1, 2, 3, 4, 5);`
  - 매개값들은 자동으로 배열 항목으로 변환되어 메소드에서 사용 -> 메소드 호출시 배열을 직접 매개값을 제공 가능.
    - `int[] values = {1, 2, 3}; int result = sum(values);` or `int result = sum(new int[] {1, 2, 3});`
#### return 문
- return문: 메소드의 실행을 강제 종료, 호출한 곳으로 돌아간다는 의미
- 메소드 선언에 리턴 타입이 있을 경우, return문 뒤에 리턴값을 추가로 지정해야함.
- Unreachable code: return문 이후에 실행문을 작성하면 발생하는 컴파일 에러
#### 메소드 오버로딩
- 메소드 이름은 같음; 매개변수의 타입, 개수, 순서가 다른 메소드를 여러 개 선언하는 것; 리턴 타입은 무관
- 목적: 다양한 매개값 처리를 위해서(다양한 타입 지원 등)
  - 대표적인 예: `System.out.println()`-호출 시 주어진 매개값의 타입에 따라서 오버로딩된 메소드 중 하나를 실행
## 9. 인스턴스 멤버
- 필드와 메소드는 선언 방법에 따라 구분
  - 인스턴스 멤버: 객체에 소속된 멤버(객체를 생성해야만 사용할 수 있는 멤버)
  - 정적 멤버: 클래스에 고정된 멤버(객체 없이도 사용할 수 있는 멤버)
### 인스턴스 멤버 선언 및 사용

## 10. 정적 멤버
## 11. final 필드와 상수
## 12. 패키지
## 13. 접근 제한자
## 14. Getter와 Setter
## 15. 싱글톤 패턴
