# 1. 상속 개념
- 상속: 부모클래스의 필드와 메소드를 자식클래스에게 물려주는 행위.
- 재사용성, 중복 코드를 줄여 개발시간 단축, 클래스의 수정을 최소화
# 2. 클래스 상속
- 자식 클래스를 선언 시 어떤 부모로부터 상속받을 것인지 결정, **extends 구문 활용**
- `public class 자식클래스 extends 부모클래스 { }`
- 다중 상속을 허용하지 않음.
# 3. 부모 생성자 호출
- 자식 객체를 생성하면 부모 객체가 먼저 생성된 다음, 자식 객체가 생성됨. 
  - `자식클래스 변수 = new 자식클래스( )`
- 모든 객체는 생성자를 호출해야만 생성됨 -> 자식 생성자의 맨 첫줄에 숨겨져있는 super()에 의해 부모 객체의 생성자가 호출됨.
  - super()는 컴파일 과정에서 자동 추가됨. 
  - 부모 클래스에 기본 생성자가 없다면 자식 생성자 선언에서 컴파일 에러 발생
    - 부모 클래스에 매개변수를 갖는 생성자만 있다면 직접 `super(매개값, ...)`코드를 넣어야함.
    ```java
    public 자식클래스(...) {
        super(매개값, ...); //매개값의 타입과 개수가 일치하는 부모 생성자를 호출
        ...
    }
    ```
# 4. 메소드 재정의
- 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수 있음 -> 자식 클래스에서 재정의해서 사용
## 메소드 오버라이딩
- 상속된 메소드를 자식 클래스에서 재정의하는 것. 
- 메소드가 오버라이딩 되었다면 해당 부모 메소드는 숨겨지고, 자식 메소드가 우선적으로 사용됨.
- 오버라이딩 관련 규칙
  - 부모 메소드의 선언부(리턴타입, 메소드 이름, 매개변수)와 동일
  - 접근 제한을 더 강하게 오버라이딩할 수 없음(public->private 불가)
  - 새로운 예외를 throws 할 수 없음.
- @Override 어노테이션: 컴파일 단계에서 정확히 오버라이딩이 되었는지 체크, 문제가 있다면 컴파일 에러를 출력
## 부모 메소드 호출
- 메소드 재정의시, 부모 메소드는 숨겨지고 자식 메소드만 사용됨 -> 부모 메소드의 일부만 변경된다하더라도 중복된 내용을 자식메소드도 가지고 있어야함 -> 자식 메소드와 부모 메소드의 공동 작업 처리 기법
- 자식 메소드 내에서 부모 메소드를 호출: `super`키워드와 `도트(.)연산자`를 사용하여 부모 메소드 호출(작업 처리 순서대로 작성하면 됨.)
# 5. final 클래스와 final 메소드
- 필드 선언 시에 final을 붙이면 초기값 설정 후 값을 변경할 수 없음
## final 클래스 
- 클래스를 선언할 때 final 키워드를 class 앞에 붙이면 최종적인 클래스->더 이상 상속할 수 없는 클래스
  - `public final class 클래스 { ... }`
  - ex. `public final class String { ... }`
## final 메소드
- 메소드를 선언할 때 final 키워드를 붙이면 최종적인 메소드 -> 오버라이딩 불가
  - 부모 클래스를 상속해서 자식 클래스를 선언할 때, 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의 불가.
  - `public final 리턴타입 메소드(매개변수, ... ) { ... }`
# 6. protected 접근 제한자
- protected: 상속과 관련된, public과 default의 중간쯤에 해당하는 접근 제한.
  - 제한대상: 필드, 생성자, 메소드
  - 제한범위: 같은 패키지이거나(내에선 default처럼 접근 가능), 자식 객체만 사용 가능
- **protected 생성자가 있는 부모클래스를 상속하는 자식클래스는 `new` 연산자 대신 `super()`로 호출**
# 7. 타입 변환
- 클래스의 타입 변환: 상속 관계에 있는 클래스 사이에서 발생
