# 3. 코딩과 디버깅에 관하여
## 3.1 도입: 코딩의 중요성을 간과하지 말라
- 프로그래밍 대회에서 좋은 성적을 올리기 위한 비결: 빨리 코딩X, 읽기 쉬운 코드를 작성(정확한 작성과 디버깅에 유리)
- 간결하고 효율적인 프로그램을 작성하는 능력

## 3.2 좋은 코드를 짜기 위한 원칙
- 프로그래밍 대회에서 특히 중요하게 적용되는 원칙들과 예외들
### 간결한 코드를 작성하기
- 코드가 짧을수록 오타/단순 버그가 생길 우려가 줄어듬, 디버깅이 쉬워짐.
- (흑마법)전역 변수의 광범위한 사용, 매크로를 이용
```cpp
//일반적인 코드
bool hasDuplicate(const vector<int>& array) {
    for(int i = 0; i < array.size(); ++i)
        for(int j = 0; j < i; ++j)
            if(array[i] == array[j])
                return true;
    return false;
}
//매크로 흑마법 사용 코드
#define FOR(i, n) for(int i = 0; i < (n); ++i)
bool hasDuplicate(const vector<int>& array) {
    FOR(i, array.size())
        FOR(j, i)
            if(array[i] == array[j])
                return true;
    return false;
}
```
- 이중 for문에서 증감식에서 변수를 착각하는 일을 없앨 수 없음.
- 실수를 피해 가는 올바른 방법: 배열의 인덱스를 반복문으로 순회하는 대신 java, C#에서처럼 foreach 구문을 사용하는 것.
### 적극적으로 코드 재사용하기
- 간결한 코드 -> 모듈화(함수, 클래스로 분리)
  - n번이상 등장하면 분리한다는 기본 원칙을 세우면 좋음
  - 실무에서 이상적인 코드: 한 함수가 두 가지 이상의 일을 해서는 안됨(분리가 필요)
### 표준 라이브러리 공부하기
- 큐, 스택과 같은 자료구조, 정렬 등의 기초 알고리즘을 직접 작성하는 것은 시간 낭비
- 표준 라이브러리는 셀 수 없을 정도로 많이 사용되고 검증 -> 메모리 관리, 정당성 증명이 검증됨.
### 항상 같은 형태로 프로그램을 작성하기
- 여러 종류의 코드를 반복적으로 짜게 됨->같은 코드를 다양한 방식으로 짜봄.
- 알아보기 쉬운 코드를 작성하는데 도움이 되지만 코드 검증에는 어려움. 그래야 **도구가 아닌 문제에 집중 가능**
### 일관적이고 명료한 명명법 사용하기
- 모호하지 않은 변수명, 함수명을 사용하기
- 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약 익히기.
  - `bool judge(int y, int x, int cy, int cx, int cr)` 대신 `bool isInsideCircle(int y, int x, int cy, int cx, int cr)`사용
### 모든 자료를 정규화해서 저장하기
- 같은 자료를 두 가지 형태로 저장하지 않는 것.
- ex. 축과 점이 이루는 각도/유리수를 표현하는 클래스 Fraction -> 기약분수로 표현해야 같은 자료가 두 개 이상의 표현을 가지지 않음
  - 문자열 표현이 달라지고, 해시값이 달라지는 등의 문제로 인한 버그 발생 가능
- ex. 프로그램이 시간을 표현할 경우 어떤 시간대로 저장되는지(썸마타임 등) 섞이기 일쑤 -> 표준에서 표시한 시간과 시간대의 조합으로 저장
- ex. 입력에 문자열 인코딩이 섞여있을 수 있으니 가능한 한 UTF-16 이나 UTF-8 인코딩으로 변환해야 다루기 쉬움
- 정규화는 프로그램이 자료를 입력받거나 계산하자마자(생성자) 곧장 이루어져야함.
### 코드와 데이터를 분리하기
- 날짜를 다루는 프로그램에서 영문이름으로 출력할 때 코드의 논리(if)와 상관없는 데이터는 배열 등으로 분리하여 다루기.
  - `const string monthName[] = { "January", "Februrary", ...}`
  - `int daysIn[12] = { 31, 28, ...}`
- 체스 같은 보드 게임은 말의 움직임을 다룰 때 움직일 수 있는 위치를 프로그램(if문 등)으로 작성하는 대신 움직일 수 있는 상대좌표를 배열에 저장해두면 좋음
  - `const int knightDx[8] = { 2, 2, -2, -2, 1, 1, -1, -1};`
  - `const int knightDy[8] = { 1, -1, 1, -1, 2, 2, 2, -2};`

## 3.3 자주 하는 실수
- 실수에서 배우기, 남의 실수로부터 배우기
### 산술 오버플로
### 배열 범위 밖 원소에 접근
- C/C++는 배열의 원소에 접근시 인덱스 범위 체크를 해주지 않음 (속도에는 좋지만 버그 찾기 힘듦)
  - 런타임 스택을 건드려서 런타임 오류를 내고 종료->디버깅 가능
  - 오류가 나지 않으면서 틀린 닶->디버깅 힘듦
  - `int array[10], t;`